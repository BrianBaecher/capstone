@using Capstone.Services
@using Capstone.Shared.Models
@namespace Capstone.Components.AdminComponents
@inject ContactService contactService
@inject IJSRuntime JS

@if (!isDataFetched)
{
	<RadzenText>LOADING</RadzenText>
}
else
{
	<RadzenAccordion>
		<Items>
			@foreach (var kvp in messageDict)
			{
				<RadzenAccordionItem Template=@CreateHeaderTemplate(kvp.Key)
									 MouseEnter="OnMouseEnter"
									 MouseLeave="OnMouseExit">
					<MessageListComponent Messages="kvp.Value"
										  Topic="kvp.Key"
										  OnReadStatusChange="UpdateUnreadMessageCount" />
				</RadzenAccordionItem>
			}
		</Items>
	</RadzenAccordion>
}

@code {
	// prop-drilling...
	[Parameter]
	public EventCallback<(ContactMessage.MessageTopic topic, bool isIncrease)> OnReadStatusChange { get; set; }

	Dictionary<ContactMessage.MessageTopic, List<ContactMessage>> messageDict = new();

	bool isDataFetched;

	RenderFragment test =@<SuccessIndicator IsSuccess=true FailureMessage="no" SuccessMessage="yes" />;

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		// should be empty dict already...
		if (messageDict.Keys.Count > 0) messageDict.Clear();

		foreach (var enumVal in Enum.GetValues<ContactMessage.MessageTopic>())
		{
			messageDict.Add(enumVal, new());
		}

		// get all the messages
		var messages = await contactService.GetMessagesAsync();

		if (messages == null)
		{
			throw new Exception("We got problems");
		}

		// separate by topic
		foreach (var msg in messages)
		{
			messageDict[msg.Topic].Add(msg);
		}

		foreach(var key in unreadMessageDict.Keys)
		{
			var n = await GetNumNotifications(key);
			unreadMessageDict[key] = n ?? 0;
		}

		isDataFetched = true;
	}

	private string TopicIconHandler(ContactMessage.MessageTopic topic)
	{
		switch (topic)
		{
			case ContactMessage.MessageTopic.Support:
				return "support";
			case ContactMessage.MessageTopic.Feedback:
				return "feedback";
			case ContactMessage.MessageTopic.Sales:
				return "money_bag";
			case ContactMessage.MessageTopic.Other:
				return "more_horiz";
			default:
				return "question_mark";
		}
	}

	private RenderFragment CreateHeaderTemplate(ContactMessage.MessageTopic topic)
	{
		RenderFragment fragment =@<AccordionHeaderTemplate HeaderText="@topic.ToString()"
								 Icon="@TopicIconHandler(topic)"
								 NumNotifications="@unreadMessageDict[topic]" />;

		return fragment;
	}

	Dictionary<ContactMessage.MessageTopic, int> unreadMessageDict = new()
	{
		{ContactMessage.MessageTopic.Support, 0},
		{ContactMessage.MessageTopic.Feedback, 0},
		{ContactMessage.MessageTopic.Sales, 0},
		{ContactMessage.MessageTopic.Other, 0},
	};

	private async Task<int?> GetNumNotifications(ContactMessage.MessageTopic topic)
	{
		return await contactService.GetUnreadCountAsync(topic.ToString());
	}

	public void UpdateUnreadMessageCount((ContactMessage.MessageTopic topic, bool isIncrease) arg)
	{
		if (arg.isIncrease)
		{
			unreadMessageDict[arg.topic]++;
		}
		else
		{
			unreadMessageDict[arg.topic]--;
		}
	}

	private async Task OnMouseEnter(ElementReference element)
	{
		var classlist = await JS.InvokeAsync<string[]>("domHelpers.getClassList", element);

		await JS.InvokeVoidAsync("domHelpers.addClass", element, "rz-background-color-info-lighter");
	}


	private async Task OnMouseExit(ElementReference element)
	{
		var classlist = await JS.InvokeAsync<string[]>("domHelpers.getClassList", element);

		await JS.InvokeVoidAsync("domHelpers.removeClass", element, "rz-background-color-info-lighter");
	}
}
